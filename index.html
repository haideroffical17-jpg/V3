<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CineVerse Ultra - AI Video Studio</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        .custom-scrollbar::-webkit-scrollbar { width: 6px; height: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #111; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #555; }
        body { background-color: #050505; color: white; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .animate-fade-in { animation: fadeIn 0.5s ease-out; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- INLINE ICONS (To prevent crashes if external libs fail) ---
        const Icons = {
            Play: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>,
            Pause: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>,
            Video: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="23 7 16 12 23 17 23 7"/><rect x="1" y="5" width="15" height="14" rx="2" ry="2"/></svg>,
            Film: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="20" height="20" x="2" y="2" rx="2.18" ry="2.18"/><line x1="7" x2="7" y1="2" y2="22"/><line x1="17" x2="17" y1="2" y2="22"/><line x1="2" x2="22" y1="12" y2="12"/><line x1="2" x2="7" y1="7" y2="7"/><line x1="2" x2="7" y1="17" y2="17"/><line x1="17" x2="22" y1="17" y2="17"/><line x1="17" x2="22" y1="7" y2="7"/></svg>,
            Layers: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"/><polyline points="2 17 12 22 22 17"/><polyline points="2 12 12 17 22 12"/></svg>,
            Type: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" x2="15" y1="20" y2="20"/><line x1="12" x2="12" y1="4" y2="20"/></svg>,
            Download: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>,
            Trash2: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>,
            SkipForward: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 4 15 12 5 20 5 4"/><line x1="19" x2="19" y1="5" y2="19"/></svg>,
            Zap: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>,
            AlertCircle: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/></svg>,
            Loader2: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>,
            Key: (props) => <svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m21 2-2 2m-7.6 7.6a6.5 6.5 0 1 1 5.3 5.3L3 21v-3.5L6 14l2-2"/></svg>
        };

        function AIVideoGenerator() {
            // --- STATE MANAGEMENT ---
            const [apiKey, setApiKey] = useState(() => localStorage.getItem('gemini_api_key') || '');
            const [showKeyInput, setShowKeyInput] = useState(false);
            
            const [prompts, setPrompts] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [scenes, setScenes] = useState([]); 
            const [currentSceneIndex, setCurrentSceneIndex] = useState(0);
            const [isPlaying, setIsPlaying] = useState(false);
            const [isRendering, setIsRendering] = useState(false); 
            const [aspectRatio, setAspectRatio] = useState('16:9');
            const [selectedModel, setSelectedModel] = useState('veo3'); 
            const [cameraMove, setCameraMove] = useState('cinematic'); 
            const [showCaptions, setShowCaptions] = useState(false);
            const [clipDuration, setClipDuration] = useState(5); 
            const [progress, setProgress] = useState(0); 
            
            const canvasRef = useRef(null);
            const requestRef = useRef(null);
            const mediaRecorderRef = useRef(null);
            const recordedChunks = useRef([]);
            const imageCache = useRef({});

            // --- API KEY HANDLER ---
            const saveApiKey = (key) => {
                setApiKey(key);
                localStorage.setItem('gemini_api_key', key);
                setShowKeyInput(false);
            };

            // --- PRELOAD IMAGES ---
            useEffect(() => {
                scenes.forEach(scene => {
                    if (!scene.image) return;
                    const img = new Image();
                    img.crossOrigin = "anonymous"; 
                    img.src = scene.image;
                    imageCache.current[scene.id] = img;
                });
            }, [scenes]);

            // --- ANIMATION LOOP ---
            const animateCanvas = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                
                let width = 1920; let height = 1080;
                if (aspectRatio === '9:16') { width = 1080; height = 1920; }
                if (aspectRatio === '1:1') { width = 1080; height = 1080; }
                
                if (canvas.width !== width) canvas.width = width;
                if (canvas.height !== height) canvas.height = height;

                const scene = scenes[currentSceneIndex];
                
                if (!scene || scene.isError) {
                    ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, width, height); return;
                }

                const img = imageCache.current[scene.id];
                if (!img || !img.complete) {
                    ctx.fillStyle = '#000'; ctx.fillRect(0, 0, width, height); return; 
                }

                const p = progress / 100;
                let scale = 1; let tx = 0; let ty = 0;

                switch (scene.movement) {
                    case 'zoomIn': scale = 1 + (p * 0.3); break;
                    case 'panLeft': scale = 1.2; tx = (width * 0.05) - (p * width * 0.1); break;
                    case 'shake': scale = 1.1; const shake = Math.sin(p * 40) * 15; tx = shake; ty = shake; break;
                    case 'cinematic': default: scale = 1 + (p * 0.15); tx = -(p * width * 0.02); ty = -(p * height * 0.02); break;
                }

                ctx.save();
                ctx.translate(width / 2, height / 2);
                ctx.scale(scale, scale);
                ctx.translate(-width / 2 + tx, -height / 2 + ty);
                
                const imgRatio = img.width / img.height;
                const canvasRatio = width / height;
                let renderW, renderH;
                
                if (canvasRatio > imgRatio) { renderW = width; renderH = width / imgRatio; } 
                else { renderH = height; renderW = height * imgRatio; }
                
                ctx.drawImage(img, (width - renderW) / 2, (height - renderH) / 2, renderW, renderH);
                ctx.restore();

                if (showCaptions) {
                    ctx.fillStyle = 'rgba(0,0,0,0.6)';
                    ctx.fillRect(0, height - 140, width, 140);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 48px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = "black";
                    ctx.shadowBlur = 10;
                    ctx.fillText(scene.text, width/2, height - 60);
                }
            };

            useEffect(() => {
                const loop = () => { animateCanvas(); requestRef.current = requestAnimationFrame(loop); };
                requestRef.current = requestAnimationFrame(loop);
                return () => cancelAnimationFrame(requestRef.current);
            }, [currentSceneIndex, progress, scenes, showCaptions, aspectRatio]);

            // --- SEQUENCER ---
            useEffect(() => {
                let interval;
                if ((isPlaying || isRendering) && scenes.length > 0) {
                    const fps = 60; const stepTime = 1000 / fps; const totalSteps = (clipDuration * 1000) / stepTime;
                    interval = setInterval(() => {
                        setProgress((old) => {
                            const newProgress = old + (100 / totalSteps);
                            if (newProgress >= 100) {
                                if (currentSceneIndex < scenes.length - 1) {
                                    setCurrentSceneIndex(prev => prev + 1);
                                    return 0; 
                                } else {
                                    if (isRendering) stopRendering();
                                    setIsPlaying(false); 
                                    return 100;
                                }
                            }
                            return newProgress;
                        });
                    }, stepTime);
                }
                return () => clearInterval(interval);
            }, [isPlaying, isRendering, currentSceneIndex, scenes.length, clipDuration]);

            const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            // --- GENERATION LOGIC ---
            const generateSingleImage = async (promptText, ratio, modelType) => {
                if (!apiKey) throw new Error("API Key Missing");

                let modelKeywords = "";
                if (modelType === 'veo3') modelKeywords = ", Veo 3 style, masterpiece, 8k resolution, highly detailed, cinematic lighting, trending on artstation, unreal engine 5, sharp focus";
                else if (modelType === 'veo') modelKeywords = ", dynamic action shot, motion blur, speed, 8k, movie scene, intense";
                else modelKeywords = ", cinematic photography, 35mm lens, f/1.8, hyper-realistic, 8k, global illumination";

                try {
                    const response = await fetch(
                        `https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict?key=${apiKey}`,
                        {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                instances: [{ prompt: promptText + modelKeywords }],
                                parameters: { sampleCount: 1, aspectRatio: ratio },
                            }),
                        }
                    );
                    if (!response.ok) {
                        const errText = await response.text();
                        throw new Error(`API Error: ${errText}`);
                    }
                    const data = await response.json();
                    if (data.predictions && data.predictions[0]) {
                        return `data:image/png;base64,${data.predictions[0].bytesBase64Encoded}`;
                    }
                    throw new Error('No output');
                } catch (error) { throw error; }
            };

            const handleGenerate = async () => {
                if (!apiKey) { setShowKeyInput(true); return; }
                
                setIsLoading(true); setIsPlaying(false);
                try {
                    const lines = prompts.split('\n').filter(line => line.trim() !== '');
                    if (lines.length === 0) return;
                    const promises = lines.map(async (line, index) => {
                        await delay(index * 500); // Stagger requests
                        try {
                            const imageUrl = await generateSingleImage(line, aspectRatio, selectedModel);
                            const sceneObj = { image: imageUrl, text: line, id: Date.now() + index + Math.random(), movement: cameraMove, isError: false };
                            setScenes(prev => [...prev, sceneObj]);
                            return sceneObj;
                        } catch (e) {
                            console.error(e);
                            const errorSceneObj = { image: null, text: `Generation Failed: ${line.substring(0, 30)}...`, id: Date.now() + index + Math.random(), movement: 'none', isError: true };
                            setScenes(prev => [...prev, errorSceneObj]);
                            return errorSceneObj;
                        }
                    });
                    await Promise.all(promises);
                    setPrompts('');
                    if (scenes.length === 0) setCurrentSceneIndex(0);
                } catch (err) { console.error(err); } 
                finally { setIsLoading(false); }
            };

            const togglePlay = () => {
                if (scenes[currentSceneIndex]?.isError) return;
                if (currentSceneIndex === scenes.length - 1 && progress >= 99) { setCurrentSceneIndex(0); setProgress(0); }
                setIsPlaying(!isPlaying);
            };

            // --- EXPORT ---
            const startRendering = () => {
                if (scenes.length === 0) return;
                setCurrentSceneIndex(0); setProgress(0); setIsRendering(true); setIsPlaying(false); 
                const canvas = canvasRef.current;
                const stream = canvas.captureStream(60); 
                const options = { mimeType: 'video/webm; codecs=vp9', videoBitsPerSecond: 8000000 };
                let mediaRecorder;
                try { mediaRecorder = new MediaRecorder(stream, options); } catch (e) { mediaRecorder = new MediaRecorder(stream); }
                mediaRecorderRef.current = mediaRecorder;
                recordedChunks.current = [];
                mediaRecorder.ondataavailable = (event) => { if (event.data.size > 0) recordedChunks.current.push(event.data); };
                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks.current, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none'; a.href = url; a.download = `CineVerse_Ultra_${Date.now()}.webm`; 
                    document.body.appendChild(a); a.click(); window.URL.revokeObjectURL(url);
                    setIsRendering(false);
                };
                mediaRecorder.start();
            };

            const stopRendering = () => { if (mediaRecorderRef.current) mediaRecorderRef.current.stop(); };

            // --- RENDER UI ---
            return (
                <div className="min-h-screen bg-[#050505] text-white font-sans pb-20">
                    
                    {/* API Key Modal */}
                    {(!apiKey || showKeyInput) && (
                        <div className="fixed inset-0 bg-black/90 z-50 flex items-center justify-center p-4">
                            <div className="bg-[#1a1a1a] border border-white/20 p-6 rounded-xl max-w-md w-full shadow-2xl animate-fade-in">
                                <div className="flex items-center gap-3 mb-4">
                                    <div className="p-2 bg-purple-600 rounded-lg"><Icons.Key className="w-6 h-6 text-white"/></div>
                                    <h2 className="text-xl font-bold">Setup Gemini API</h2>
                                </div>
                                <p className="text-gray-400 text-sm mb-4">To use CineVerse on the web, you need your own free Gemini API Key from Google AI Studio.</p>
                                <input 
                                    type="password" 
                                    placeholder="Paste API Key here (AIza...)" 
                                    className="w-full bg-black border border-white/20 rounded-lg p-3 text-white mb-4 focus:border-purple-500 outline-none"
                                    onKeyDown={(e) => { if(e.key === 'Enter') saveApiKey(e.target.value); }}
                                />
                                <button onClick={(e) => saveApiKey(e.target.previousSibling.value)} className="w-full bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 rounded-lg transition-all">
                                    Save & Start Creating
                                </button>
                                <div className="mt-4 text-center">
                                    <a href="https://aistudio.google.com/app/apikey" target="_blank" className="text-xs text-purple-400 hover:text-purple-300 underline">Get a free API Key here</a>
                                </div>
                            </div>
                        </div>
                    )}

                    <header className="border-b border-white/5 bg-[#090909]/95 backdrop-blur-xl sticky top-0 z-30">
                        <div className="max-w-7xl mx-auto px-4 py-4 flex items-center justify-between">
                            <div className="flex items-center gap-3">
                                <div className="bg-gradient-to-tr from-purple-600 to-indigo-600 p-2 rounded-xl shadow-lg shadow-purple-500/20">
                                    <Icons.Film className="w-5 h-5 text-white" />
                                </div>
                                <div><h1 className="text-lg font-black text-white tracking-wider">CINEVERSE <span className="text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-indigo-400">ULTRA</span></h1></div>
                            </div>
                            <div className="flex gap-3">
                                <button onClick={() => setShowKeyInput(true)} className="p-2 rounded-full bg-white/5 hover:bg-white/10 text-gray-400 hover:text-white transition-colors" title="API Settings"><Icons.Key className="w-4 h-4"/></button>
                                <button onClick={startRendering} disabled={scenes.length === 0 || isRendering} className={`flex items-center gap-2 px-6 py-2 rounded-full text-xs font-bold tracking-wide transition-all shadow-lg ${isRendering ? 'bg-gray-800 text-gray-400 cursor-not-allowed' : 'bg-white text-black hover:bg-indigo-500 hover:text-white hover:scale-105'}`}>
                                    {isRendering ? <><Icons.Loader2 className="w-3 h-3 animate-spin" /> Rendering...</> : <><Icons.Download className="w-4 h-4" /> Render 4K</>}
                                </button>
                            </div>
                        </div>
                    </header>

                    <main className="max-w-7xl mx-auto px-4 py-8 grid grid-cols-1 lg:grid-cols-12 gap-8">
                        <div className="lg:col-span-4 space-y-6 h-[calc(100vh-120px)] overflow-y-auto custom-scrollbar pr-2">
                            <div className="bg-[#111] border border-white/10 rounded-2xl p-5 shadow-xl">
                                <h2 className="text-xs font-bold text-gray-500 uppercase tracking-widest mb-4 flex items-center gap-2"><Icons.Type className="w-4 h-4" /> Script Editor</h2>
                                <textarea value={prompts} onChange={(e) => setPrompts(e.target.value)} placeholder={"Step 1: Enter Scenes (1 Line = 1 Clip)\n\nExample:\nA futuristic samurai walking in neon rain\nClose up of his cybernetic eye"} className="w-full bg-[#1a1a1a] border border-white/10 rounded-xl p-4 text-sm focus:ring-2 focus:ring-purple-500 outline-none min-h-[200px] resize-none text-gray-200 font-medium leading-relaxed placeholder:text-gray-600" />
                                <div className="grid grid-cols-2 gap-4 mt-4">
                                    <div>
                                        <label className="text-[10px] font-bold text-gray-500 uppercase mb-1.5 block">Visual Engine</label>
                                        <select value={selectedModel} onChange={(e) => setSelectedModel(e.target.value)} className="w-full bg-[#1a1a1a] text-xs border border-white/10 rounded-lg px-3 py-3 text-gray-300 outline-none focus:border-purple-500">
                                            <option value="veo3">Veo 3 (Ultra Realistic)</option><option value="veo">Veo 2 (Action)</option><option value="imagen">Imagen 4 (Standard)</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label className="text-[10px] font-bold text-gray-500 uppercase mb-1.5 block">Format</label>
                                        <select value={aspectRatio} onChange={(e) => setAspectRatio(e.target.value)} className="w-full bg-[#1a1a1a] text-xs border border-white/10 rounded-lg px-3 py-3 text-gray-300 outline-none focus:border-purple-500">
                                            <option value="16:9">16:9 Landscape</option><option value="9:16">9:16 Verticle</option><option value="1:1">1:1 Square</option>
                                        </select>
                                    </div>
                                </div>
                                <div className="mt-4">
                                    <label className="text-[10px] font-bold text-gray-500 uppercase mb-1.5 block">Camera Motion</label>
                                    <div className="grid grid-cols-4 gap-2">
                                        {['cinematic', 'zoomIn', 'panLeft', 'shake'].map((m) => (
                                            <button key={m} onClick={() => setCameraMove(m)} className={`py-2 rounded-lg border text-[10px] uppercase font-bold transition-all ${cameraMove === m ? 'bg-purple-600 border-purple-500 text-white' : 'border-white/10 text-gray-500 hover:bg-white/5'}`}>{m.replace('cinematic', 'Auto')}</button>
                                        ))}
                                    </div>
                                </div>
                                <button onClick={handleGenerate} disabled={isLoading || !prompts.trim()} className={`w-full mt-6 flex items-center justify-center gap-2 py-4 rounded-xl font-bold text-xs uppercase tracking-wider transition-all shadow-lg ${isLoading ? 'bg-gray-800 text-gray-500 cursor-not-allowed' : 'bg-gradient-to-r from-purple-600 to-indigo-600 text-white hover:shadow-purple-500/30 hover:scale-[1.02]'}`}>
                                    {isLoading ? <><Icons.Loader2 className="w-4 h-4 animate-spin" /> Generating...</> : <><Icons.Zap className="w-4 h-4 fill-current" /> Generate Scenes</>}
                                </button>
                            </div>
                            {scenes.length > 0 && (
                                <div className="bg-[#111] border border-white/10 rounded-2xl p-5">
                                    <div className="flex justify-between items-center mb-4">
                                        <h3 className="text-xs font-bold text-gray-500 uppercase tracking-widest flex items-center gap-2"><Icons.Layers className="w-4 h-4" /> Timeline</h3>
                                        <button onClick={() => setScenes([])} className="text-red-400 hover:text-red-300 bg-red-900/20 p-1.5 rounded-lg transition-colors"><Icons.Trash2 className="w-3 h-3"/></button>
                                    </div>
                                    <div className="space-y-2 max-h-[300px] overflow-y-auto custom-scrollbar pr-2">
                                        {scenes.map((scene, idx) => (
                                            <div key={scene.id} onClick={() => { setCurrentSceneIndex(idx); setIsPlaying(false); setProgress(0); }} className={`flex items-center gap-3 p-2 rounded-xl cursor-pointer transition-all border ${currentSceneIndex === idx ? 'bg-purple-500/10 border-purple-500/50' : 'bg-[#1a1a1a] border-transparent hover:border-white/10'}`}>
                                                <div className="w-6 h-6 rounded-full bg-white/5 flex items-center justify-center text-[10px] font-mono text-gray-400 border border-white/5">{idx+1}</div>
                                                {scene.isError ? <div className="flex-1 flex items-center gap-2 text-red-400 text-xs"><Icons.AlertCircle className="w-3 h-3" /> Failed</div> : <div className="flex-1 min-w-0"><p className="text-xs text-gray-200 truncate font-medium">{scene.text}</p><div className="flex gap-2 mt-0.5"><span className="text-[9px] text-gray-500 bg-black/30 px-1.5 py-0.5 rounded capitalize">{scene.movement}</span></div></div>}
                                                {scene.image && !scene.isError && <img src={scene.image} className="w-10 h-10 rounded-lg object-cover border border-white/10" />}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>
                        <div className="lg:col-span-8 flex flex-col h-[calc(100vh-120px)]">
                            <div className="flex-1 bg-[#000] border border-white/10 rounded-2xl relative overflow-hidden flex items-center justify-center shadow-2xl">
                                <canvas ref={canvasRef} className={`shadow-2xl transition-all ${scenes.length > 0 ? 'opacity-100' : 'opacity-0'}`} style={{ maxWidth: '100%', maxHeight: '100%', aspectRatio: aspectRatio === '16:9' ? '16/9' : aspectRatio === '9:16' ? '9/16' : '1/1', boxShadow: '0 0 50px rgba(0,0,0,0.5)' }} />
                                {isRendering && (
                                    <div className="absolute inset-0 bg-black/80 z-50 flex flex-col items-center justify-center backdrop-blur-sm">
                                        <div className="w-24 h-24 relative mb-6"><div className="absolute inset-0 border-4 border-purple-500/20 rounded-full"></div><div className="absolute inset-0 border-4 border-t-purple-500 rounded-full animate-spin"></div></div>
                                        <h2 className="text-2xl font-bold text-white mb-2">Rendering Video...</h2>
                                        <p className="text-gray-400 text-sm mb-4">Processing Scene {currentSceneIndex + 1} of {scenes.length}</p>
                                        <div className="w-64 h-1.5 bg-gray-800 rounded-full overflow-hidden"><div className="h-full bg-purple-500 transition-all duration-300" style={{ width: `${((currentSceneIndex / scenes.length) * 100) + (progress / scenes.length)}%` }}></div></div>
                                    </div>
                                )}
                                {scenes.length === 0 && !isLoading && (
                                    <div className="text-center absolute opacity-50 pointer-events-none">
                                        <div className="w-24 h-24 bg-[#111] rounded-3xl flex items-center justify-center mx-auto mb-6 border border-white/10 rotate-3"><Icons.Video className="w-10 h-10 text-purple-500" /></div>
                                        <h3 className="text-xl font-bold text-white mb-2">CINEVERSE ULTRA</h3>
                                        <p className="text-gray-500 text-sm max-w-xs mx-auto leading-relaxed">Enter your story script on the left to generate unlimited high-quality clips.</p>
                                    </div>
                                )}
                                {!isRendering && scenes.length > 0 && (
                                    <div className="absolute bottom-0 w-full bg-gradient-to-t from-black via-black/60 to-transparent p-8 z-10 opacity-0 hover:opacity-100 transition-opacity duration-300">
                                        <div className="flex items-center justify-center gap-6">
                                            <button onClick={() => { const newIdx = currentSceneIndex - 1; if (newIdx >= 0) { setCurrentSceneIndex(newIdx); setProgress(0); } }} className="p-2 rounded-full hover:bg-white/10 text-white transition-colors"><Icons.SkipForward className="w-6 h-6 rotate-180" /></button>
                                            <button onClick={togglePlay} className="w-16 h-16 bg-white rounded-full flex items-center justify-center text-black hover:scale-110 hover:bg-purple-50 transition-all shadow-xl">
                                                {isPlaying ? <Icons.Pause className="w-6 h-6 fill-current" /> : <Icons.Play className="w-6 h-6 fill-current ml-1" />}
                                            </button>
                                            <button onClick={() => { const newIdx = currentSceneIndex + 1; if (newIdx < scenes.length) { setCurrentSceneIndex(newIdx); setProgress(0); } }} className="p-2 rounded-full hover:bg-white/10 text-white transition-colors"><Icons.SkipForward className="w-6 h-6" /></button>
                                        </div>
                                        <div className="absolute bottom-8 right-8"><button onClick={() => setShowCaptions(!showCaptions)} className={`p-2 rounded-lg border transition-all ${showCaptions ? 'bg-white text-black border-white' : 'bg-black/50 text-gray-400 border-white/20 hover:bg-black/70'}`} title="Toggle Captions"><Icons.Type className="w-5 h-5" /></button></div>
                                    </div>
                                )}
                            </div>
                            <div className="h-32 mt-6 relative">
                                <div className="absolute inset-0 bg-[#111] border border-white/10 rounded-2xl overflow-hidden flex items-center px-4">
                                    <div className="flex gap-2 overflow-x-auto custom-scrollbar w-full pb-2 pt-2">
                                        {scenes.map((scene, idx) => (
                                            <div key={scene.id} onClick={() => { setCurrentSceneIndex(idx); setIsPlaying(false); setProgress(0); }} className={`relative h-20 min-w-[120px] rounded-xl overflow-hidden cursor-pointer border-2 transition-all flex-shrink-0 ${currentSceneIndex === idx ? 'border-purple-500 opacity-100 shadow-lg shadow-purple-500/20 scale-105 z-10' : 'border-white/5 opacity-50 hover:opacity-80'}`}>
                                                {scene.isError ? <div className="w-full h-full bg-red-900/20 flex items-center justify-center"><Icons.AlertCircle className="w-5 h-5 text-red-500" /></div> : <img src={scene.image} className="w-full h-full object-cover" />}
                                                <div className="absolute bottom-0 left-0 right-0 bg-black/70 text-[9px] px-2 py-1 truncate text-gray-300 font-medium backdrop-blur-sm">{idx+1}. {scene.text}</div>
                                                {currentSceneIndex === idx && !scene.isError && !isRendering && <div className="absolute bottom-0 left-0 top-0 bg-purple-500/30 border-r-2 border-purple-500 transition-all duration-75 z-20" style={{ width: `${progress}%` }}></div>}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </main>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<AIVideoGenerator />);
    </script>
</body>
</html>
