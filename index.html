<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Make Meta-AI Bookmarklet — Single File</title>
  <style>
    body{font-family:Inter,Arial,Helvetica,sans-serif;padding:18px;max-width:820px;margin:12px auto;color:#111}
    h1{margin:0 0 6px;font-size:20px}
    p{margin:6px 0;color:#333}
    textarea,input{width:100%;box-sizing:border-box;padding:8px;margin-top:8px;font-size:14px}
    button{padding:8px 12px;margin-top:10px;cursor:pointer}
    .row{display:flex;gap:8px}
    .row button{flex:1}
    #bookmarkletLink{display:inline-block;margin-top:12px;padding:8px;background:#0a66c2;color:white;border-radius:6px;text-decoration:none}
    .note{font-size:13px;color:#555;margin-top:8px}
    pre{background:#f6f6f6;padding:10px;border-radius:6px;overflow:auto}
  </style>
</head>
<body>
  <h1>Single-file Meta AI Bookmarklet Maker</h1>
  <p>Paste your prompts (one per line). Click <strong>Generate Bookmarklet</strong>, then drag the blue link to your bookmarks bar (or right-click → Bookmark this link). Open <strong>Meta AI</strong> tab, make it active, then click that bookmark to run automation on the page.</p>

  <label>Prompts (one per line):</label>
  <textarea id="prompts" rows="8" placeholder="Write one prompt per line..."></textarea>

  <label>Delay between prompts (ms)</label>
  <input id="delay" type="text" value="2000" />

  <label>Timeout to wait for 'Download' (ms)</label>
  <input id="timeout" type="text" value="90000" />

  <div class="row">
    <button id="generate">Generate Bookmarklet</button>
    <button id="copyCode">Copy Bookmarklet JS</button>
  </div>

  <a id="bookmarkletLink" href="#" draggable="true" title="Drag to bookmarks bar">Drag this to bookmarks bar after generation</a>

  <div class="note">
    <strong>How to use:</strong>
    <ol>
      <li>Save this page (or keep it open).</li>
      <li>Enter prompts & click <em>Generate Bookmarklet</em>.</li>
      <li>Drag the blue link to your bookmarks bar, or right-click it → "Add to bookmarks".</li>
      <li>Open <em>meta.ai</em> or <em>ai.meta.com</em>, make the tab active, then click the bookmark (the script will run on that page).</li>
    </ol>
    <strong>Limitations:</strong> The bookmarklet runs in the context of the page you click it on. It cannot upload files automatically (browser blocks programmatic file selection). Make sure your media are already uploaded on the page if needed.
  </div>

  <h3>Bookmarklet JavaScript (read-only, for advanced users)</h3>
  <pre id="jsCode"></pre>

<script>
(function(){
  const promptsEl = document.getElementById('prompts');
  const delayEl = document.getElementById('delay');
  const timeoutEl = document.getElementById('timeout');
  const generateBtn = document.getElementById('generate');
  const copyBtn = document.getElementById('copyCode');
  const link = document.getElementById('bookmarkletLink');
  const jsCodePre = document.getElementById('jsCode');

  // Core function that will be injected as bookmarklet.
  // Keep it self-contained (no external deps).
  function bookmarkletCore(promptsArray, options){
    // This function runs INSIDE the target page when bookmarklet clicked.
    (async function runPrompts(){
      // Utility: sleep
      const sleep = ms => new Promise(r => setTimeout(r, ms));

      // CONFIG — adjust fallback selectors/keywords
      const PROMPT_SELECTORS = [
        'textarea[placeholder*="prompt"]',
        'textarea[placeholder*="Write"]',
        'textarea[aria-label*="Message"]',
        'textarea',
        'div[contenteditable="true"]'
      ];
      const RUN_KEYWORDS = ['run','generate','create','submit','send','ask','go'];
      const DOWNLOAD_KEYWORDS = ['download','save','export','download image','download result','save image','save result'];

      function findPromptEl(){
        for(const s of PROMPT_SELECTORS){
          try{
            const el = document.querySelector(s);
            if(el) return el;
          }catch(e){}
        }
        // try searching for a contenteditable near common containers
        const contentEditable = Array.from(document.querySelectorAll('[contenteditable="true"]')).find(e => {
          // prefer larger elements
          return (e.innerText || '').length < 10000;
        });
        return contentEditable || null;
      }

      function setPromptText(el, text){
        el.focus();
        if(el.tagName && el.tagName.toLowerCase() === 'textarea'){
          el.value = text;
          el.dispatchEvent(new Event('input', {bubbles:true}));
          el.dispatchEvent(new Event('change', {bubbles:true}));
        } else {
          // contenteditable
          el.innerText = text;
          el.dispatchEvent(new InputEvent('input', {bubbles:true}));
        }
      }

      function clickButtonByKeywords(words){
        // search visible buttons/links with matching text
        const nodes = Array.from(document.querySelectorAll('button, a'));
        // try exact visible buttons first (text content)
        for(const n of nodes){
          const t = (n.innerText || '').toLowerCase().trim();
          if(!t) continue;
          for(const w of words){
            if(t.includes(w)) {
              // ensure element is visible and enabled
              const rect = n.getBoundingClientRect();
              if(rect.width > 0 && rect.height > 0 && !n.disabled){
                try { n.click(); return n; } catch(e) {}
              }
            }
          }
        }
        return null;
      }

      function tryClick(selector){
        try{
          const el = document.querySelector(selector);
          if(el) { el.click(); return el; }
        }catch(e){}
        return null;
      }

      async function waitForDownloadButton(timeoutMs){
        const start = Date.now();
        // quick check
        if(clickButtonByKeywords(DOWNLOAD_KEYWORDS)) return true;

        return new Promise((resolve, reject) => {
          const obs = new MutationObserver(() => {
            if(clickButtonByKeywords(DOWNLOAD_KEYWORDS)){
              obs.disconnect();
              clearInterval(poll);
              resolve(true);
            }
            if(Date.now() - start > timeoutMs){
              obs.disconnect();
              clearInterval(poll);
              reject(new Error('timeout'));
            }
          });
          obs.observe(document.body, {childList:true, subtree:true, attributes:true, characterData:true});
          const poll = setInterval(()=>{
            if(clickButtonByKeywords(DOWNLOAD_KEYWORDS)){
              obs.disconnect();
              clearInterval(poll);
              resolve(true);
            }
            if(Date.now() - start > timeoutMs){
              obs.disconnect();
              clearInterval(poll);
              reject(new Error('timeout'));
            }
          }, 800);
        });
      }

      // Start running prompts
      const delay = (options && options.delay) || 1500;
      const timeout = (options && options.timeout) || 90000;

      // safety: show a tiny on-page status so user knows bookmarklet ran
      const statusNode = document.createElement('div');
      statusNode.style.position = 'fixed';
      statusNode.style.right = '12px';
      statusNode.style.bottom = '12px';
      statusNode.style.zIndex = 2147483647;
      statusNode.style.background = 'rgba(10,10,10,0.85)';
      statusNode.style.color = 'white';
      statusNode.style.padding = '8px 10px';
      statusNode.style.borderRadius = '8px';
      statusNode.style.fontSize = '13px';
      statusNode.style.fontFamily = 'Arial,sans-serif';
      statusNode.textContent = 'Meta-AI Bookmarklet running...';
      document.body.appendChild(statusNode);

      for(let i=0;i<promptsArray.length;i++){
        try{
          const text = promptsArray[i];
          statusNode.textContent = `Running ${i+1}/${promptsArray.length}...`;

          // find prompt element
          const promptEl = findPromptEl();
          if(!promptEl){
            console.warn('Bookmarklet: prompt field not found');
            statusNode.textContent = 'Prompt field not found — stopped';
            break;
          }

          // set prompt text
          setPromptText(promptEl, text);

          // click run / generate
          const runBtn = clickButtonByKeywords(RUN_KEYWORDS);
          if(!runBtn){
            // attempt common selectors as fallback
            clickButtonByKeywords(['submit']);
          }

          // wait a bit for generation to start
          await sleep(500);

          // now wait until a Download/Save button appears (or timeout)
          try{
            await waitForDownloadButton(timeout);
            // if download button appears, we already clicked it inside waitForDownloadButton
            // small delay to let download start
            await sleep(800);
            statusNode.textContent = `Downloaded ${i+1}/${promptsArray.length}`;
          }catch(e){
            // timeout waiting for download
            console.warn('Bookmarklet: timeout waiting for download for prompt index', i);
            statusNode.textContent = `Timeout on ${i+1}/${promptsArray.length}`;
          }

          // polite delay before next prompt
          await sleep(delay);

        }catch(err){
          console.error('Bookmarklet error:', err);
          statusNode.textContent = 'Error occurred — check console';
          break;
        }
      } // end for

      // finish
      statusNode.textContent = 'Bookmarklet finished';
      setTimeout(()=>{ try{ document.body.removeChild(statusNode) }catch(e){} }, 4000);

    })();
  } // end bookmarkletCore

  // convert function to bookmarklet code string
  function makeBookmarkletCode(prompts, delay, timeout){
    // we will stringify the function and embed prompts/options
    const fnString = "(" + bookmarkletCore.toString() + ")(" + JSON.stringify(prompts) + "," + JSON.stringify({delay:+delay, timeout:+timeout}) + ");";
    // minify-ish: remove newlines and excessive spaces for safety
    const min = fnString.replace(/\s+/g,' ').trim();
    // create final javascript: URL
    return 'javascript:(function(){' + encodeURIComponent(min) + '})()';
  }

  function updateUIWithCode(code){
    // display readable code too (decoded)
    try{
      const decoded = decodeURIComponent(code.replace(/^javascript:\(function\(\)\{/, '').replace(/\}\)\(\)$/, ''));
      jsCodePre.textContent = decoded;
    }catch(e){
      jsCodePre.textContent = code;
    }
    link.href = code;
    link.textContent = 'Drag this link to bookmarks bar (or right-click → bookmark)';
  }

  generateBtn.addEventListener('click', ()=>{
    const prompts = promptsEl.value.split('\n').map(s => s.trim()).filter(Boolean);
    if(prompts.length === 0){ alert('Please enter at least one prompt.'); return; }
    const delay = parseInt(delayEl.value) || 1500;
    const timeout = parseInt(timeoutEl.value) || 90000;
    const code = makeBookmarkletCode(prompts, delay, timeout);
    updateUIWithCode(code);
    alert('Bookmarklet generated. Drag the blue link to your bookmarks bar and then open Meta AI page and click it there.');
  });

  copyBtn.addEventListener('click', ()=>{
    const href = link.href;
    if(!href || href === '#'){ alert('Generate the bookmarklet first.'); return; }
    // copy JS to clipboard (decoded)
    const decoded = decodeURIComponent(href);
    navigator.clipboard.writeText(decoded).then(()=> alert('Bookmarklet code copied to clipboard. You can paste it into a bookmark or share.'), ()=> alert('Copy failed — try manually drag the link.'));
  });

  // init placeholders
  link.href = '#';
  jsCodePre.textContent = 'Click "Generate Bookmarklet" to produce the JS code here.';
})();
</script>
</body>
</html>
